'use strict';

const K6Helper = require('../k6-helper');
const _ = require('phenom');
const $ = require('genesis');
const Conduit  = require('conduit');

const _match = _.match((m) => m[0]);
const _round = _.round(2);
const $prefix = /^(?:.+?\.)?(.+)$/;
const $gui = /^(.+?)Gui$/;
const $decimals = 2;
const _typed = _.attach('$type', (value) => {
  return { configurable: true, writable: true, value };
});

_.attach(Number.prototype, 's', {
  get() {
    return this + 's';
  },
  configurable: true
});

function unprefix(attr) {
  return _match(attr.name, $prefix);
}

function drop_Gui(value) {
  if (_.isObject(value)) {
    value = value.guiclass;
  }
  return _match(value, $gui);
}

class {
  _convertCollection(item, result, allVariables) {

    var self = this;

    if (ItemGroup.isItemGroup(item)) {
      var folder = item;
      if (folder.auth) { throw new Error(' TODO: folder.auth'); }

      result.push('');
      result.push(_.format("  group(\"%s\", function() {\n", folder.name));

      result.push("    let res;");

      folder.items.each(function(folderItem, index) {
        self._convertCollection(folderItem, result, allVariables);
      });

      result.push("  });\n");

    } else if (Item.isItem(item)) {

      k6Request = makeRequest(item);

      if (k6Request.variables) {
        k6Request.variables.forEach(function(item) {
          allVariables.push(item);
        });
      }
      result.push(k6Request.result);

    } else {

      throw new Error(' TODO: Implement postCollection item');

    }

  }
  convert(postmanCollection) {

    if (!postmanCollection || postmanCollection.items.count() === 0 ) {
      return '// No HTTP/HTTPS transactions have been recorded.';
    }

    const MAX_REDIRECTS = 4;

    var result = [],
        folderRequests,
        requests = [],
        allVariables = [],
        k6Request,
        self = this;


    result.push(_.format("// Auto-generated by the Load Impact converter"));
    result.push("");
    result.push("import { group } from \"k6\";");
    result.push("import http from \"k6/http\";")
    result.push("");
    result.push("export let options = {");
    result.push(_.format("  maxRedirects: %s", MAX_REDIRECTS));
    result.push("}");
    result.push("");

    result.push("export default function() {");

    var hasRequestsAtRootLevel = false;
    postmanCollection.items.each(function(item) {
      if (Item.isItem(item)) {
        hasRequestsAtRootLevel = true;
      }
    });

    if (hasRequestsAtRootLevel) {
      result.push("    let res;");
    }

    postmanCollection.items.each(function(item) {

      self._convertCollection(item, result, allVariables);

    });

    if (allVariables.length) {

      allVariables = dedupe(allVariables);

      result.splice(4, 0, "");
      for (var j = allVariables.length - 1; j >= 0; j--) {

        result.splice(4, 0, _.format("let %s = \"YOUR_VALUE\";", allVariables[j]));

      }
      result.splice(4, 0, "");

    }

    result.push("}");

    return result.join('\n');

  }
}
class K6Generator {
  convert(data) {
    let script = $(), options = $({});
    script.commentBlock('Auto-generated by the Load Impact converter');
    
    let stages = options('stages', []), serialized;
    let params = $({});
    let $headers = params('headers', {});
    let $default = script.export('default', $.function());
    $default.let('jar', $.new('http', 'CookieJar'));
    let conduit = Conduit({
      'TestPlan $T'(node, T) {
        if (this.enabled === false)
          return node();  // disabled -> nothing more to be done; bailing out

        let { 
          comments, 
          serialize_threadgroups = false,
        } = node.bundle('$property', unprefix);
        options.commentBlock(comments);
        serialized = serialize_threadgroups;
      },
      ConfigTestElement(node) {
        let type = drop_Gui(node);
        let bundle = node.bundle('$property', unprefix);
        
        switch (type) {
          case 'LoginConfig':
            let {
              username = '',
              password = '',
            } = bundle;
            break;
          case 'LdapConfig':
            let {
              servername = '',
              port = '',
              rootdn = '',
              user_defined = false,
              test = '',
              base_entry_dn = '',
            } = bundle;
            break;
          case 'LdapExtConfig':
            let {
              user_pw = '',
              user_dn = '',
              port = '',
              deref_aliases = '', 
              return_object = '',
              scope = '',
              rootdn = '',
              servername = '',
              modddn = '',
              comparefilt = '',
              comparedn = '',
              countlimit = '',
              timelimit = '',
              newdn = '',
              suser_pw = '',
              suser_dn = '',
              attributes = '',
            } = bundle;
            break;
          case 'FtpConfig':
            let {
              server = '',
              filename = '',
            } = bundle;
            break;
          case 'HttpDefaults':
            let {
              domain = '',
              path = '',
              port = '',
              protocol = '',
            } = bundle;
            break;
          case 'JndiDefaults':
            let {
              contextProviderUrl = '',
              initialContextFactory = '',
            } = bundle;
            break;
          case 'TCPConfig':
            let {
              request = '',
              nodelay = '',
              server = '',
              timeout = '',
              port = '',
              reUseConnection = '',
              closeConnection = '',
              ctimeout = '',
              EolByte = '',
            } = bundle;
            break;
        }
      },
    /* $threads */
      $ThreadGroup(node) {
        let {
          on_sample_error,
          num_threads,
          delay = 0,
          ramp_time,
          start_time,
          end_time,
          scheduler,
          duration = 0,
          main_controller = { loops: 0 }
        } = node.bundle('$property', unprefix);
        let loops = main_controller.loops || 0;
        
        switch (node.name) {
          case 'ThreadGroup':
            let _delay = ramp_time / num_threads;
            for (let i of _.range(num_threads) {
              if (delay > 0) {
                stages.push({ target: i, duration: delay.s });
              }
              let _duration = _round(Math.max(duration, _delay));
              stages.push({ target: i + 1, duration: _duration.s });
            }
        /* 
          ...the correct distribution of VUs should be handled in the 
          export default function using __VU and if/else JS statements - how?
        */
            
            break;
          case 'SetupThreadGroup':
            script.export($.function('setup', [
              $.commentBlock(`NOTE: The JMeter setUp thread group was configured to run with ` + 
                `${ num_threads } VUs for ${ duration }s${ loops > 0 ? `/${ loops } iterations` : '' }`);
            ]));
            break;
          case 'PostThreadGroup':
            script.export($.function('teardown', [
              $.commentBlock(`NOTE: The JMeter tearDown thread group was configured to run with ` + 
                `${ num_threads } VUs for ${ duration }s${ loops > 0 ? `/${ loops } iterations` : '' }`);
            ]));
            
            break;
        }
      },
      $SteppingThreadGroup(node) {
        let {
          on_sample_error,
          num_threads,
          'Threads initial delay': delay,
          'Start users count': start_count = 0,
          'Start users count burst': start_burst = 0,
          'Start users period': start_period,
          'Stop users count': stop_count = 0,
          'Stop users period': stop_period,
          flighttime,
          rampUp,
          main_controller
        } = node.bundle('$property', unprefix);
        
        if (start_count == 0) {
          start_count = num_threads;
        }
        if (stop_count == 0) {
          stop_count = num_threads;
        }
        start_burst = Math.min(start_burst, num_threads);
        if (start_burst <= 0) {
          start_burst = start_count;
        }
        
        stages.push({ target: 0, duration: delay.s });
        stages.push({ target: start_burst, duration: start_period.s });
        
        let iterations = num_threads < start_burst ? 1 : Math.ceil((num_threads - start_burst) / start_count);
        for (let i of _.range(iterations) {
          let target = num_threads + i * delay;
          stages.push({ target, duration: rampUp.s });
          if (start_period > 0) {
            stages.push({ target, duration: start_period.s });
          }
        }
        stages.push({ target: num_threads, duration: flighttime.s });
        stages.push({ target: 0, duration: _round(num_threads * stop_period / stop_count).s });
        
      },
      $threads(node) {
        if (!serialized) {
          // split stages into multiple objects to be selected via CLI or env
        }
      },
    /* $manager */
      DNSCacheManager(node) {
        let {
          servers = {}, // { "...": 
          clearEachIteration,
          isCustomResolver
        } = node.bundle('$property', unprefix);
        
        if (servers.$type == 'collection') {
          options('hosts', servers);
        }
      },
      HeaderManager(node) {
        let { headers } = node.bundle('$property', unprefix);
        _.values(headers, ({ name, value }) => {
          $headers(name, value);
        });
      },
      CookieManager(node) {
        let { cookies, clearEachIteration } = node.bundle('$property', unprefix);
        _.values(cookies, ({ name, testname, value: { value, domain, path, secure, expires, domain_specified, path_specified }}) => {
          let opts = $({ secure, expires });
          if (domain_specified) {
            opts('domain', domain);
          }
          
          if (path_specified) {
            opts('path', path);
          }
          
          $('jar', 'set')($domain, name, testname, value, opts);
        });
      },
      AuthManager(node) {
        let { auth_list } = node.bundle('$property', unprefix);
        _.values(auth_list, ({ mechanism = 'basic' }) => {
          
        });
      },
    /* $assertion */
      $JSONPathAssertion(node) {
        let {
          JSON_PATH: path,
          EXPECTED_VALUE: value,
          JSONVALIDATION: validate,
          EXPECT_NULL: nullable
        } = node.bundle('$property', unprefix);
        
        //this.value = { path, value, validate, nullable };
        // ...
      },
      DurationAssertion(node) {
        let { duration = 0 } = node.bundle('$property', unprefix);
        if (duration > 0) {
          $('check')($('res'), {
            `request takes at most ${ duration }s`: 
              $.lambda(['res'], $($('res', 'timings', 'duration'), '<=', duration))
          });
        }
      },
      ResponseAssertion(node) {
        let {
          test_strings,
          test_field,
          assume_success,
          test_type,
          custom_message
        } = node.bundle('$property', unprefix);
        
        // finish up...
      },
    /* $controller */
      'ForeachController $T'(node, s) {
        let {
          returnVal,
          inputVal,
          useSeparator
        } = node.bundle('$property', unprefix);
        
        
      },
      'IfController $T'(node, T) {
        
      },
      'InterleaveControl $T'(node, T) {
        
      },
      'LoopController $T'(node, T) {
        
      },
      'OnceOnlyController $T'(node, T) {
        
      },
      'WhileController $T'(node, T) {
        
      },
      'RunTimeController $T'(node, T) {
        
      },
      'TransactionController $T'(node, T) {
        
      },
      'SimpleController $T'(node, T) {
        
      },
      'RandomController $T'(node, T) {
        
      },
    /* $timer */
      ConstantTimer(node) {
        
      },
    /* $postProcessor */
      HtmlExtractor(node) {
        
      },
      CSSSelectorExtractor(node) {
        
      },
      RegexExtractor(node) {
        
      },
      ResultStatusActionHandler(node) {
        
      },
    /* misc */
      $xpath(node) {
        $.commentBlock(`Currently K6 has no XPath API of its own; ` + 
          `as a viable alternative, try https://www.npmjs.com/package/wicked-good-xpath.`);
      },
      $comment(node) {
        
      },
      $element(node) {
        if (this.enabled === false) {
          node.skip();
        }
      },
      stringProp(node) {
        let value = node.bundle();
        let num = parseInt(value);
        return isNaN(num) ? value : num;
      },
      $numeric(node) {
        return parseInt(node.bundle());
      },
      boolProp(node) {
        return node.bundle() == 'true';
      },
      elementProp(node) {
        if (this.enabled === false)
          return node.skip();
          
        let value = node.bundle('$property', unprefix);
        switch (this.elementType) {
          case 'Authorization':
            value.name = value.domain || value.url;
          case 'Header':
            return value;
          default:
            this.value = value;
        }
      },
      collectionProp(node) {
        let bundle = node.bundle('$property', unprefix);
        return _typed(bundle, 'collection');
      },
      $: {
        attr: {
          enabled(value) {
            return value == 'true';
          },
        },
        schema: {
          jmeterTestPlan: {
            $T: ['$T', 'TestPlan', '$element'],
          }
        },
        lexicon: {
          numeric: ['longProp', 'intProp'],
          property: ['stringProp', '$numeric', 'boolProp', 'elementProp', 'collectionProp'],
          T: ['hashTree'],
          SteppingThreadGroup: ['kg.apc.jmeter.threads.SteppingThreadGroup'],
          ThreadGroup: ['ThreadGroup', 'SetupThreadGroup', 'PostThreadGroup'],
          threads: ['$ThreadGroup', '$SteppingThreadGroup'],
          manager: ['DNSCacheManager', 'HeaderManager', 'CookieManager', 'AuthManager'],
          JSONPathAssertion: ['com.atlantbh.jmeter.plugins.jsonutils.jsonpathassertion.JSONPathAssertion'],
          assertion: ['$JSONPathAssertion', 'DurationAssertion', 'ResponseAssertion', 'XPathAssertion '],
          controller: [
            'ForeachController', 'LoopController', 'OnceOnlyController', 'WhileController', 'IfController', 'InterleaveControl', 
            'GenericController', 'RunTimeController', 'TransactionController', 'SimpleController', 'RandomController'
          ],
          timer: ['ConstantTimer'],
          data: ['CSVDataSet'],
          xpath: ['XPathAssertion', 'XPathExtractor'],
          comment: ['$preProcessor', 'JSR223PostProcessor', 'BeanShellPostProcessor'],
          preProcessor: ['JSR223PreProcessor', 'BeanShellPreProcessor'],
          JSONPathExtractor: ['com.atlantbh.jmeter.plugins.jsonutils.jsonpathextractor.JSONPathExtractor'],
          postProcessor: [
            'JSONPostProcessor', '$JSONPathExtractor', 'HtmlExtractor', 'CSSSelectorExtractor', 'XPathExtractor',
            'BoundaryExtractor', 'RegexExtractor', 'ResultStatusActionHandler', 'JSR223PostProcessor', 'BeanShellPostProcessor'
          ],
          component: ['$manager', '$assertion', '$controller', '$timer', '$data', '$preProcessor', '$postProcessor'],
          element: ['ConfigTestElement', '$threads', '$component']
        }
      }
    });
    conduit(data);
    return $(script, { comment: true });
  }
}


function makeRequest(item) {

  var request = item.request,
      body = request.body,
      method,
      url,
      data,
      postRequest,
      preRequest,
      auth = request.auth,
      headerHash = {},
      authHeader,
      headers = [];


  // read method & url
  method = request.method;
  url = request.url.toString();


  // read test and preRequest functions
  if (item.events.count() > 0) {

    item.events.each(function(event) {
      var script;
      if (event.listen === 'test') {
        script = event.script.exec;
        if (script.length) {
          //js commented
          postRequest = _.format("\n    /**\n    %s\n    **/\n", script.join('\n    '));
        }
      } else if (event.listen === 'prerequest') {
        script = event.script.exec;
        if (script.length) {
          //jscommented
          preRequest = _.format("\n    /**\n    %s\n    **/\n", script.join('\n    '));
        }
      }
    });

  }


  // get headers & auth into headerHash
  request.headers.each(function(header) {
    headerHash[header.key] = header.value;
  });

  // add or overwrite auth header
  if (auth && auth.type) {

    var AuthenticationManager = $require('./auth/' + auth.type);
    if (AuthenticationManager && AuthenticationManager.enabled) {

      authHeader = AuthenticationManager.header(request);

      // convert headerHash to arrayHeaders
      if (authHeader) {
        delete headerHash.Authorization;
        headers.push(authHeader);
      }
    } else {

      var authenticationComment;
      if (auth.type === 'awsv4' || auth.type === 'hawk' || auth.type === 'oauth1') {

        authenticationComment = _.format("Note: %s dynamic authentication is not supported", auth.type);

      } else if (auth.type === 'digest') {

        authenticationComment = _.format("Note: %s dynamic digest authentication is not supported", auth.type);

      }

      if (authenticationComment) {

        postRequest = postRequest || '';
        postRequest += _.format("    /** \n    %s\n    **/\n", authenticationComment);

      }


    }
  }


  Object.keys(headerHash).forEach(function(key) {
    var tmpHeader = _.format("\"%s\" : \"%s\"", key, K6Helper.escapeContent(headerHash[key]));
    headers.push(tmpHeader);
  });


  // read body
  var bodyData = body[body.mode];
  if (bodyData) {

    if (body.mode === RequestBodyModes.raw) {
      data = K6Helper.escapeContent(bodyData);
    } else if (bodyData.count() > 0) {
      //body.mode === RequestBodyModes.formdata
      //body.mode === RequestBodyModes.urlencoded
      //should we add default CONTENT-TYPE Header `application/x-www-form-urlencoded`?

      var params = [];
      bodyData.each(function(paramItem) {
        params.push(_.format('%s=%s', encodeURIComponent(paramItem.key), encodeURIComponent(paramItem.value)));
      });

      data = params.join('&');

    }

  }

  return K6Helper.buildK6Request({
    url: url,
    method: method,
    headers: headers,
    data: data,
    preRequest: preRequest,
    postRequest: postRequest,
    variable: 'res'
  });

}

function $require(name) {
  try { return require(name); }
  catch(e) { return false; }
}

module.exports = K6Generator;
